# 멱등성이 중요한 이유 !

## Async 통신의 한계
- 특정 상황들에서는 필연적으로 두 번 이상 데이터를 받을 **가능성 존재**
- Async 통신의 장점이 명확하고, 사용하기에 매우 적절한 경우들이 존재하나 한계 존재
  - e.x. Logging Pipeline, UX 상 빠른 리턴 후 결과는 나중에 보여줘도 되는 케이스

#### Logging Pipeline
- Log Write to File -> File Scraping -> Pipeline ..... -> Indexing .... -> Kibana(Elastic Search)
- 이런 곳은 내부에 버퍼링 풀을 둬서 누락 없이 사용 함 


---
**e.x. 땡땡페이 내 대출 가능 여부 조회 플랫폼**
- 인증
- 각 기관들에서 대출 가능여부를 확인하고 있는 중이에요. 완료되면 알림톡을 보내드릴께요!
- 완료이벤트를 수신하여 XX톡 발송 // 이후 중요한 정보를 관리하는 외부 기관 프로세싱 수행 등 


## 그렇다면, Async 통신을 활용해서 중요한 비즈니스를 하기는 어렵다? 
- 상황
  - 2번 이상 수신되는 것이 문제
  - 중요한 비즈니스에서도 리소스 활용을 최적화 하고 싶다!

- **2번 이상 수신되어도, 괜찮을 수 있는 방법이 없을까?**
- -> 멱등성이 필요한 상황 식별!

#### 멱등성이란? 
- 간단히 말해서, 특정 호출이 1번 혹은 여러번 호출되어도 서버의 상태는 1번 호출된 것과 동일해야 한다 라는 특성!
  - 일반적으로 Update, Delete 요청은 멱등성을 가지며, Create 요청은 멱등성을 가지지 않는다.

**-> Sync 통신에서는 멱등성을 비즈니스 로직으로 구현 하면됨!**


## Async 통신에서의 멱등성
- Async 통신에서는 기본적으로 멱등성이 보장되지 않는 통신 방식
- 그럼에도 멱등성을 구현하기 위해서는 "다른 무언가가 필요"
- 멱등성 구현을 위한 DB Table(RDB)를 사용해서 멱등성을 구현할 수 있다!

**queue_log**

|                     |                                  |
|---------------------|----------------------------------|
| message_id          | 특정 큐잉 메세지의 고유 식별자                |
| status              | 메세지의 상태(대기중, 처리중, 완료)            |
| created_timestamp   | Producer로 부터 메세지가 큐에 추가된 시간      |
| processed_timestamp | Consumer로부터 메세지가 큐에서 처리된 시간      |
| processed_status    | Consumer로부터 처리된 메세지의 결과 (성공, 실패) |


## 멱등성이 구현된 Producer, Consumer

### 멱등성 구현 이전.
Producer는 항상 메세지를 생성하여 큐에 추가하고, Consumer는 항상 메시지를 처리


### 멱등성 구현 이후.

#### MessageProduce 시, 
- Produce 전에, queue_log 테이블에 동일한 message_id 가 존재하는지 확인
  - 존재할 경우, 이미 수행되었으므로 에러/스킵 처리
  - 존재하지 않을 경우. 새로운 메세지를 큐에 추가

#### Message Consume 시,
- Consume 전에, queue_log 테이블에서 message_id의 상태를 확인
  - 처리된 경우 혹은 처리중인 status 인 경우, 중복 처리로 간주하여 에러/스킵 처리
  - 처리되지 않은 경우, message_id 의 status 값을 처리중으로 변경 후에 메세지 처리
    - 성공 시 , processed_status 값을 처리 성공으로 처리
    - 실패 시 , processed_status 값을 처리 실패로 처리


> 이것이 정답은 아니고 이해를 위한 예시!

## 명등성이 구현된 메세징 솔루션
- 멱등성이 워낙 중요하므로, 여러 메세징 오픈소스에서도 기능을 내장하는 경우가 있다
  - e.x. Exactly Once
- 하지만 앞에서 봤다시피 기본적으로 메세징(큐잉)은 멱등성을 보장하지 않는다
  - 즉, 멱등성 기능을 제공한다는 말은 앞에서 살펴보았던 멱등성 보장 프로세스를 내장하고 있다는 뜻!
- 당연히 사용하지 않는 것에 비해서는 퍼포먼스(성능)적인 차이가 존재

> 단순히 Exactly Once를 지원하네요. 가 아니라 내부적으로는 이런식으로 동작하겠네 가 중요!


## 결론
IPC -> Inter Process Communication -> 다수의 Process

일반적으로 Process = Service -> IPC 는 서비스 간의 통신!

IPC의 방식에는 크기 Sync, Async 방식이 존재

**Sync** : Http, grpc

**Async** : 메시지 큐잉

Async 통신의 한계, 그러나 가지는 장점이 한계를 뛰어넘기 때문에, 이를 극복하기 위한 멱등성 식별

최근의 메세징 시스템은 멱등성 기능을 내재하는 Exactly Once 기능을 제공하기도 함

**현상을 그대로 받아들이는 것이 아니라, 왜 이런 기능들이 나오게 되었을까를 생각해보자**