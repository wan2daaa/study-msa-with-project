# MSA와 소프트웨어 아키텍처의 관계

## MSA 환경에서 소프트웨어 아키텍처가 중요한 이유

- MSA는 모놀리스로부터 분리/분해된 Micro Services들의 모음
- Micro Services 들을 이루는 비즈니스/도메인은 경우에 따라 , 시간이 지남에 따라 복잡도 증가
- 개별적인 Micro Service 내에서도 **비즈니스적인 목적에 따라 별개의 기능, 효율을 중요시 해야하는 상황** 발생
  - 엔지니어 적인 부분에서 영향을 미칠 가능성이 높음!


- Micro Service를 이루는 소프트웨어 아키텍처에 따라, 각 Micro Service의 Business Capabilities 변화


## MSA는 광의의(넓은 의미의) 소프트웨어 아키텍처
- 즉, 유연성, 확장성, 낮은 응집도/ 결합도 등 MSA의 특성이 각 Micro Service 안에서도 필요한 이유!

1. 당장 요청에 대한 완료 응답을 필요는 없지만(Async) , 높은 성능을 요구하는 작업(트리거링 API)
  - e.x. 대규모 Command 작업을 수행하는 Cron Job

2. 당장 응답해야하지만(sync), 적은 성능을 요구하는 작업
   - e.x. 일반적인 조회-Query 서비스 
     - 여기서 남은 성능을 다른 곳에서 활용하면됨! 결국 비즈니스 케파가 높아진다!

3. 호출하던 외부 서비스의 스펙이 변경되는 경우
   - Request/Response Params가 변동 되었고, 영향도 없이 빠르게 적용이 필요한 경우
   - 성능이 조정되어, 최적의 Connection Pool 갯수 혹은 timeout 수치가 변경되는 경우

4. 통신 방식이 변경되는 경우
   - Sync 방식에서 Async 방식으로 변경되어 비동기 Callback 방식으로 같은 로직을 처리할 경우


### MSA는 느슨하게 결합된 서비스의 집합 

- MSA의 느슨한 MS의 결합 
  - -> 유연성, 확장성 증가! 
- 각 MS 는 소프트웨어 아키텍처에 따라 설계
- 유연성, 확장성이 높은 소프트웨어 아키텍처
  - 참고 : 항상 유연성, 확장성이 높은게 답은 아니다
- 기술 다양성이 높은 MS는 작은 단위의 비즈니스 케파를 만들어 줄 수 있다


## 대표적인 2개의 소프트웨어 아키텍처 - Layered & Hexagonal

### Layered Architecture (계층화 아키텍처)
- 여러개의 계층으로 나누어 각 계층에서 하는 일을 한정시켜 계층별로 독립적으로 개발, 배포, 확장이 가능!
- Presentation / Application / Domain / Infra Layer 등으로 이루어짐
- 각 계층 내에서는 코드 수정과 유지보수 등이 비교적 쉽다. 
- 계층간 접근이 자유롭다

### Hexagonal Architecture (헥사고날 아키텍처)
- 각 계층에서 하던 일들을 "내부와 외부" 라는 개념으로 나누어 각각에 맞는 별도의 인터페이스를 정의
- "내부"의 로직은 **오직 "외부" 인터페이스를 통해서만 접근이 가능**
- 모든 비즈니스 로직은, **오직 외부에서 내부 방향으로만 호출이 가능!**
- 경계 간 이동이 제한 됨