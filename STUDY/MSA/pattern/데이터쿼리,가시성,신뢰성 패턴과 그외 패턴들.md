# 데이터쿼리,가시성,신뢰성 패턴과 그외 패턴들

## 데이터 쿼리 패턴
MSA 소프트웨어 아키텍처를 설계 하면서 생긴 **"데이터 쿼리"** 의 어려움을 해결하기 위한 패턴 

### API Aggregation(조합) 패턴
필요한 데이터를 얻어오기 위해서, 분리된 서비스들 각각에 각 도메인에 대한 데이터를 요청후 필요에 맞게 Aggregation

e.x. 송금이 최종적으로 성공한 요청 건에 대해서, 같이 실행된 외부 은행에 대한 계좌 요청드르이 외부 API 호출 횟수

### CQRS 패턴 

- Command 란? CUD 에 해당 하는 작업  

Command(Write, Update, Delete) 작업과, Query(Read) 작업의 Endpoint 를 분리하고,

Command 에서의 발생된 데이터의 변경을 이벤트 발행을 통해 원하는 포맷대로 Query를 위한 저뇽 데이터 구조를 만들어

이곳에서 복잡한 Query를 담당.

- Read 와 Command 작업을 완전히 분리 시켜두고,
- Command작업은 계속 작업을 진행되게 하고, 
- Read는 Command의 이벤트 발행을 확인해서 원하는 포맷대로 Query를 위한 전용 데이터 구조를 만들어 복잡한 Query를 담당  

e.x. 강남구에 사는 모든 주민들의 잔액 총합을 실시간으로 알고 싶다면?


## 가시성 (Visibility, Observability)

MSA 소프트웨어 아키텍처를 설계하면서 생긴 로깅,모니터링의 어려움(가시성의 부재)을 해결하기 위한 패턴

**로깅의 메트릭의 중앙집중 및 필터링 등을 통한 한곳에서의 모니터링 <- 사실상 표준!**

하나의 트랜잭션에 대해 여러개의 각 서비스 요청들을 하나의 요청처럼 볼 수 있게 하는 트레이싱(jaeger,...)

---
###### 로깅과 메트릭의 차이?

- 로깅의 목적 : 트러블 슈팅을 위한 목적! 
  - 누락 되면 안된다!

- 메트릭의 목적 : 지표들을 시계열로 저장(Prometheus), 메트릭은 주기가 중요! 시간에 따라서 증감을 보는 목적, 
  - 누락이 되어도 괜찮다

---

> 구체적으로 어떻게 로깅하고, 메트릭을 저장하고 인덱싱하여 검색할 지에 집중하는 패턴
>
> 어느정도로 표준이 존재한다!
 

## 신뢰성 패턴 (Reliability)

MSA 소프트웨어 아키텍처를 설계하면서, **분리/분해로 인해 떨어진 신뢰성을 해결**하기 위한 패턴

**장애 복구, 자가 치유, 무정지 배포** 등을 구현하기 위한 패턴들이 이에 속함!

- 백엔드 개발자 입장에서 무정지 배포란 Graceful Shutdown 이라는 뜻
  - 기존 앱이 존재하고, 수정한 앱을 다시 생성할 때,
  - 기존 앱에게 트래픽을 못 보내게 하고 막고, 갖고 있는 트랜잭션 자원을 정리하고, 종료시킴
  - 그리고 비워진 부분에 새로 배포할 앱을 넣어줌 
    - 여기서 메모리 웜업 등 작업이 있음 
  - 그렇게 health 가 완료되면, 새로운 앱이 트래픽을 받음

- e.x. **서킷 브레이커(Circuit Breaker)**
  - 신뢰성을 높이기 위한 패턴의 일종으로, 분산 시스템에서 장애 전파를 막고 피해를 최소화 하기 위한 패턴

---
  - e.x. 만약 A-> B로 갔을때 res 로 200 , B-> C로 갔을 때 res가 500이 떨어지면, 이에 따라 B에 연결된 여러 노드가 문제가 발생할 수 있다! 이런 문제를 해결하기 위한 부분
    - 만약 여기서 B에 Curcuit Breaker가 있으면,
    - 특정 조건이 있을 때 C로 나가는 요청을 모두 차단 시키고, 
    - A-> B로 왔던 부분에 200을 주고 Circuit Breaker가 발동되었다고 알려줌! 
    - 적어도 A가 장애가 되는 부분을 막아줌
      - A는 그럼 그 데이터를 보고 따로 저장할 수 있고 어느정도 신뢰가 생기게 만들 수 있음
    - 그리고 폴링 방식등을 활용해서 C가 괜찮아 졌는지 확인하고, 
    - 해결시, 자동으로 파이프를 열고, A에게도 정상적인 응답을 줌 


## 테스트 패턴, 외부 API 패턴, 디스커버리 패턴, EDA, BFF, ...

### 테스트 패턴
분리된 서비스들이 서로 빈번하게 호츨되는 모놀리식과는 다른 환경 MSA환경에서,

여러 테스트 방식을 적용하여 **테스트** 의 본질적인 의미를 해결하기 위한 패턴

e.x. 단위 테스트, 통합 테스트, E2E 테스트 (종단간 테스트)

### 외부 API 패턴
서비스 간의 통신 시 **내부 구현과 관련된 종속성을 해결하기 위한 패턴**

어떤 서비스가 다른 특정 서비스를 호출할 때 -> 직접 호출하는 것이 아닌 **리버스 프록시 역할을 하는 인터페이스 
서비스**를 제공하여 마이크로서비스 간 내부 구현방식과 무관하게 유연성을 가질 수 있는 패턴

-> 서비스 호출 시에는 "필요한 데이터" 만, 실제 구현은 상황에 따라 유연하게.

### 디스커버리 패턴
수 많은 컨테이너, 서버들의 상태를 정상적으로 관리하기 어려웠던 문제를 해결하기 위한 패턴.

수 많은 서비스들이 정상적으로 동작하는지를 판단하고, 상황에 따라 적절한 동작을 하는 메커니즘을 제공하는 패턴

e.x. 쿠버네티스의 Rediness Probe, Liveness Probe (디스커버리 패턴을 이루기 위한 수단들)

- Rediness Probe: K8S가 계속 정상인지 물어보고, 만약 응답이 없으면 비정상이라고 판단하고, 죽임
- Liveness Probe: K8S가 서버들이 정상적으로 살아있느닞 판단, Rediness에서는 안걸릴 수있지만, Liveness에서는 걸릴 수있다.

비교적 높은 상태의 신뢰성을 가지면서 기존 상태들을 확인해주는 수단이자 도구 

## 결론
모놀리식 환경에서는 비교적 쉬운 방식으로 구현이 가능했던 것들이

MSA 환경에서는 굉장이 Challenging 한 문제로 다가오게 됨.

준비 되어 있지 않다면, MSA는 재앙이 될 수 도 있다. Always Why & Because