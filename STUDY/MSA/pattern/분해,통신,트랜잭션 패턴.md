# 분해, 통신, 트랜잭션 패턴

## 분해 패턴 

MSA 소프트웨어 아키텍처를 설계함에 있어서,

모놀리식 비즈니스 구조를 **어떤 판단 기준에 따라 서비스를 분리할 것인지**에 대한 패턴

즉, **"분해"**를 해결하기 위한 능력

### 비즈니스 능력에 따른 분해 (Business Ability)
복잡한 "비즈니스 능력"을 기준으로 서비스를 분해 

e.x. 송금 서비스, 주문 서비스, ...

---
예시) 아까 송금 서비스에서

비즈니스 능력 분해 결과 (송금이라는 행동)

if, 송금이라는 비즈니스에 대해 송금을 도메인으로 정의하고, AML, CTR, STR 등 시스템을 하위 도메인으로 정의한다면? 

```text
AML : 자금 세탁 방지
CTR, STR: 고액, 의심 현금 거래
```
-> 하위 도메인 패턴 분해에 대한 결과물 일수도!
송금 비즈니스 -> 송금 서비스,AML/CTR/STR 서비스


---
### 하위 도메인 패턴별 (Sub-Domain) from DDD(도메인 주도 개발)

복잡한 비즈니스일지라도, 포함된 내부의 하위 도메인을 단위로 분리.

자신이 관리하는 도메인만 변경 가능하게 하고, 이 변경을 상위 도메인이 필요하면, 상위도메인에서 호출해서 변경한다.

e.x. 송금 -> 계좌 도메인, 내부 머니 도메인, 뱅킹 (외부 은행과 통신만 담당), ...

---

예시) 아까 송금 서비스에서

하위 도메인 패턴 분해 

고객, 계좌라는 도메인으로 분리



> 어떤 패턴으로 분리했다는게 절대적이지는 않다.
> 일반적으로 개발하고 운영하다보면 명확하지 않을 수 도 있다.



### 비즈니스 능력에 따른 분해 (Business Ability) 장단점

#### 장점
- 비즈니스가 복잡하고, 대규모 조직의 경우
- 비즈니스 특성으로 인해 **내부 서비스간 통신이 매우 빈번할 경우**

#### 단점
- 서비스 간 응집도, 결합도, 종속성 증가
- 서비스, 즉 도메인 별 팀의 구조가 희석될 가능성
  - from 콘웨이의 법칙


### 하위 도메인 패턴별 분해 (Domain) from DDD 장단점

#### 장점
- 서비스 간 독립성, 격리성이 증가 / 결합도 감소
- 서비스 간 종속성 최소화, **서비스 간 영향도 감소**
- 장애 영향도 최소화
- MSA 철학에 부합하는 패턴

#### 단점
- 서비스 간 **불필요한 통신 가능성.(HTTP, gRPC) 성능 이슈**
- 지나치게 많은 서비스로 분리될 가능성
- 대규모 시스템에서는 비효율성 크게 증가 가능성


## 통신 패턴
MSA 설계를 통해 도출된 서비스 간 어떤 방식으로 통신을 할 지 결정하는 패턴 

즉, **"통신"** 을 해결하기 위한 패턴 

### Sync Pattern (동기 패턴)
- 어떤 서비스가 다른 서비스로 특정 Request 이후, 그 Response를 받을 때 까지 멈춰있어도 되는 경우

e.x. HTTP(Restful), gRPC

### Async Pattern (비동기 패턴)
- 어떤 서비스가 다른 서비스로 특정 Request 이후, 그 Response를 당장은 받지 않아도 되는 경우
  - 비동기 response 를 처리하는 로직을 **Callback**

e.x. Kafka 등을 이용한 Message Queueing, Callback, Polling , ...

## 트랜잭션 패턴
MSA 설계를 통해 도출된 서비스를 사용하여 트랜잭션을 해결해주기 위한 패턴

즉, **"트랜잭션"** 을 해결하기 위한 패턴!

### 2PC (2Phase Commit)
"트랜잭션의 완료" 를 **2(N) 단계**에 거쳐서 결정

`Commit Request -> (정말 커밋해도 되니?) -> 실패시 Rollback , 성공시 Commit`

- 이 2phase에 코디네이터로 보낼 때 문제가 생길 수도 있기 때문에 조금 불안정함
- 커밋 Request가 성공하고 다른 시스템에서 실패했을 때 Rollback 요청을 Cordinator에게 알려줘야하는데 
- 이 문제를 알려주는 시점에서 이 요청자체가 못 날라갈 수 있다! 
### Compensating Transactions (보상 트랜잭션)
특정 요청과 그 요청에 대해 정상적이고 완전히 종료된 "행동"(트랜잭션) 을 그 이전 상태로 되돌리기 위한 "행동" (트랜잭션)

- 가능하다면, 이 트랜잭션 패턴을 사용하지 않아도 되는 상황이 있다면, 그것이 베스트! 
- 어디까지 실패하고 성공하는걸 구분하는게 정말 어렵다!

### Saga Pattern(사가 패턴)
트랜잭션의 선, 후 관계를 사전에 정의하고 필요와 경우에 따라 Cordinator가 보상 트랜잭션을 이용, 관리하여

분산시스템 환경에서 트랜잭션을 구현하기 위한 패턴 

- 2PC 와 보상 트랜잭션의 장점들을 합친 패턴
- 1번 노드가 성공하면, sage start 한다고 Cordinator한테 보내줌
- 그리고 계속 진행되었다가, 3번 노드가 문제가 생기면 Cordinator한테 보내줘서
- 이 보상 트랜잭션을 1번 노드에게 보내줌 
- saga start 후 특정 timeout 이 지났을 때 자동적으로 보상 로직을 실행시키는 로직을 실행시키게 만들 수 도 있음
  - 이 Cordinator 를 어떤걸로 만들지 고민됨 
    - 누락이 되면 안되어서 비동기로 Event를 구현해야함 
    - 누락을 처리하기 위해서는 비동기가 좋음 

